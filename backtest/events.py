"""
Event types for the event-driven backtesting engine.

The backtest engine processes events in a pipeline:
    MarketEvent -> Strategy -> SignalEvent -> Portfolio -> OrderEvent -> Broker -> FillEvent
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum


class SignalDirection(Enum):
    """Direction of a trading signal."""

    LONG = 1
    SHORT = -1
    EXIT = 0


@dataclass(slots=True)
class MarketEvent:
    """Represents a new bar of market data arriving.

    Attributes:
        timestamp: Bar timestamp.
        open:      Bar open price.
        high:      Bar high price.
        low:       Bar low price.
        close:     Bar close price.
        volume:    Bar volume.
        bar_index: Sequential index of the bar in the data series.
    """

    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    bar_index: int


@dataclass(slots=True)
class SignalEvent:
    """Generated by a strategy when it identifies a trading opportunity.

    Attributes:
        timestamp: Time the signal was generated.
        direction: LONG, SHORT, or EXIT.
        strength:  Signal conviction from 0.0 to 1.0, used for position sizing.
    """

    timestamp: datetime
    direction: SignalDirection
    strength: float = 1.0

    def __post_init__(self) -> None:
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(
                f"Signal strength must be between 0.0 and 1.0, got {self.strength}"
            )


@dataclass(slots=True)
class OrderEvent:
    """Represents an order to be submitted to the broker.

    Attributes:
        timestamp:          Time the order was created.
        direction:          LONG, SHORT, or EXIT.
        quantity:           Number of contracts.
        order_type:         "MARKET" or "LIMIT".
        limit_price:        Required if order_type is "LIMIT".
        stop_loss:          Absolute price level for stop loss, or None.
        take_profit:        Absolute price level for take profit, or None.
        take_profit_levels: Multi-level TP as list of (price, qty) tuples.
                            Mutually exclusive with take_profit.
    """

    timestamp: datetime
    direction: SignalDirection
    quantity: int
    order_type: str = "MARKET"
    limit_price: float | None = None
    stop_loss: float | None = None
    take_profit: float | None = None
    take_profit_levels: list[tuple[float, int]] | None = None

    def __post_init__(self) -> None:
        if self.order_type not in ("MARKET", "LIMIT"):
            raise ValueError(
                f"order_type must be 'MARKET' or 'LIMIT', got '{self.order_type}'"
            )
        if self.order_type == "LIMIT" and self.limit_price is None:
            raise ValueError("limit_price is required for LIMIT orders")
        if self.quantity <= 0:
            raise ValueError(f"Order quantity must be positive, got {self.quantity}")
        if self.take_profit_levels is not None:
            if self.take_profit is not None:
                raise ValueError(
                    "Cannot set both 'take_profit' and 'take_profit_levels'"
                )
            total_tp_qty = sum(qty for _, qty in self.take_profit_levels)
            if total_tp_qty != self.quantity:
                raise ValueError(
                    f"take_profit_levels total qty ({total_tp_qty}) "
                    f"must equal order quantity ({self.quantity})"
                )


@dataclass(slots=True)
class FillEvent:
    """Represents a filled (executed) order from the broker.

    Attributes:
        timestamp:  Time the fill occurred.
        direction:  Direction that was filled.
        quantity:   Number of contracts filled.
        fill_price: Actual execution price (including slippage).
        commission: Dollar commission charged.
        slippage:   Dollar cost of slippage.
    """

    timestamp: datetime
    direction: SignalDirection
    quantity: int
    fill_price: float
    commission: float
    slippage: float
